
-- alter session set "_ORACLE_SCRIPT"=true;
-- create user mary identified by "0110";
-- grant all privileges to mary;
-- select user from dual;

-- TASK1
create table MARY.MyTable(ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, val number);


-- drop table mary.MyTable;
-- ALTER TABLE MARY.MyTable
-- ADD CONSTRAINT PM PRIMARY KEY (ID);
-- select table_name from user_tables;


-- TASK2
declare
    l_num number;
begin
    for i in 1..10000 loop
        l_num := floor(dbms_random.Value(1,10000));
        insert into MARY.MyTable (val) values(l_num);
    end loop;
end;



 select * from MARY.MyTable;
--
-- DELETE from mary.MyTable;



-- TASK3
DECLARE
    even integer := 0;
    uneven integer := 0;
    result varchar2(10);
FUNCTION findMaxOccurrences
RETURN varchar2
IS
    z varchar2(10) := 'EQUAL';
BEGIN
    select count(val) into even from Mary.MyTable where MOD(val, 2) = 0;
    select count(val) into uneven from Mary.MyTable where MOD(val, 2) <> 0;
    if even > uneven then
        z := 'TRUE';
    elsif even < uneven then
        z := 'FALSE';
    end if;
    RETURN z;
END;
BEGIN
     result := findMaxOccurrences;
    dbms_output.put_line(' Maximum occurrences of even numbers: ' || result);
END;


--TASK4

-- SELECT * FROM USER_SYS_PRIVS where PRIVILEGE like 'CREATE%';

create or replace FUNCTION mary.generateInsertCommandById(idx in number)
RETURN varchar2
as
    command varchar2(100) := 'insert into Mary.MyTable(value) values (';
    value number;
    null_value_exc EXCEPTION;

BEGIN
    select val into value from MARY.MyTable where ID = idx;
    IF(value IS NULL) THEN
        RAISE null_value_exc;
    END IF;
    command := command || value ||');' ;
    RETURN command;

    EXCEPTION
    WHEN NO_DATA_FOUND THEN
    RETURN 'INCORRECT ID';
    WHEN null_value_exc THEN
    RETURN 'null value';

END;



DECLARE
    id_input integer := 0;
    result varchar2(100);
BEGIN
    select id into id_input from mary.MyTable SAMPLE(1) where rownum <= 1;
    result := mary.generateInsertCommandById(id_input);
    dbms_output.put_line('Generated command: ' || result);
END;




--TASK5
CREATE PROCEDURE Mary.insert_proc(value IN NUMBER) IS
BEGIN
    INSERT INTO Mary.MyTable(val) VALUES(value);
END;

CREATE PROCEDURE Mary.update_proc(idx IN INTEGER, new_val IN NUMBER) IS
BEGIN
    UPDATE Mary.MyTable SET val=new_val WHERE id = idx;
END;

CREATE PROCEDURE Mary.delete_proc(idx IN INTEGER) IS
BEGIN
    DELETE FROM Mary.MyTable WHERE id = idx;
END;

-- call Mary.insert_proc(1);
-- select Mary.generateInsertCommandById(1) from dual;



--Task6


CREATE OR REPLACE FUNCTION mary.count_yearly_salary(monthly_salary in number, bonuses_perc in number)
RETURN NUMBER
AS
    yearly_salary NUMBER;
    negative_monthly_salary EXCEPTION;
    null_monthly_salary EXCEPTION;
    negative_bonuses_perc EXCEPTION;
    null_bonuses_perc EXCEPTION;
BEGIN
    IF(monthly_salary < 0) THEN
        RAISE negative_monthly_salary;
    END IF;

    IF(monthly_salary IS NULL) THEN
        RAISE null_monthly_salary;
    END IF;

    IF(bonuses_perc < 0) THEN
      RAISE negative_bonuses_perc;
    END IF;

    IF(bonuses_perc IS NULL) THEN
      RAISE null_bonuses_perc;
    END IF;

    yearly_salary := (1 + bonuses_perc / 100) * 12 * monthly_salary;

    RETURN yearly_salary;

    EXCEPTION
    WHEN negative_monthly_salary THEN
       BEGIN
            DBMS_OUTPUT.put_line('negative monthly salary');
            RETURN(0);
        END;
    WHEN negative_bonuses_perc THEN
        BEGIN
            DBMS_OUTPUT.put_line('negative bonuses');
            RETURN(0);
        END;
    WHEN null_monthly_salary THEN
        BEGIN
            DBMS_OUTPUT.put_line('null monthly salary');
            RETURN(0);
        END;
    WHEN null_bonuses_perc THEN
        BEGIN
            DBMS_OUTPUT.put_line('null bonuses');
            RETURN(0);
        END;
END;


select mary.count_yearly_salary(-1, 1) from dual;

select mary.count_yearly_salary(1, -1) from dual;

select mary.count_yearly_salary(null, 1) from dual;

select mary.count_yearly_salary(0, null) from dual;

select mary.count_yearly_salary(0.6, 4) from dual;